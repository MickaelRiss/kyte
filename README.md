# Aegis

Aegis is a desktop application that secures cryptocurrency seed phrases using **AES-256-GCM encryption** and **Shamir secret sharing**. It encrypts your seed with a passphrase, then splits the result into 3 fragments — any 2 of which (plus the passphrase) can recover the original seed.

## Why Aegis?

Storing a seed phrase in a single location is a single point of failure. If it's found, your funds are gone. If it's lost, your funds are gone.

Aegis solves this with two layers of protection:

1. **Encryption** — Even if someone finds a fragment, they can't do anything without the passphrase.
2. **Shamir splitting** — The encrypted data is split into 3 pieces. No single fragment contains enough information to reconstruct the seed. You need at least 2.

This means you can distribute fragments across different locations and people. Losing one fragment doesn't lock you out, and finding one fragment doesn't compromise you.

## How it works

<img width="829" height="635" alt="Screenshot 2026-01-30 at 11 17 15 AM" src="https://github.com/user-attachments/assets/52861833-4834-4aff-bef9-d1950244213a" />
<img width="553" height="599" alt="Screenshot 2026-01-30 at 11 17 38 AM" src="https://github.com/user-attachments/assets/658b8b07-a59c-4b40-befa-db26501aa52d" />

```
Seed phrase + Passphrase
        │
        ▼
   BIP39 validation & normalization
        │
        ▼
   AES-256-GCM encryption (PBKDF2-SHA512 key derivation)
        │
        ▼
   Shamir 2-of-3 secret sharing
        │
        ▼
   3 fragments as QR codes
```

### Fragment distribution

Each fragment is meant to be stored in a different place:

| Fragment | Where to store it | How |
|----------|-------------------|-----|
| **A** | You keep it | Print the QR code, store in a safe or lockbox |
| **B** | Trusted person | Print the QR code, give to family or a close friend |
| **C** | Cloud storage | Upload the QR image to Google Drive, iCloud, AWS, etc. |

### Recovery

To recover your seed, you need **any 2 of the 3 fragments** plus your **passphrase**. For example:
- Fragment A + Fragment B + passphrase
- Fragment A + Fragment C + passphrase
- Fragment B + Fragment C + passphrase

## Security details

### Encryption

- **Algorithm:** AES-256-GCM (authenticated encryption)
- **Key derivation:** PBKDF2 with SHA-512, 100,000 iterations
- **Salt:** 64 bytes, randomly generated per encryption
- **IV:** 16 bytes, randomly generated per encryption
- **Authentication tag:** GCM provides built-in integrity verification — any tampering is detected on decryption

### Shamir secret sharing

- **Threshold:** 2-of-3 — any 2 fragments can reconstruct the encrypted data
- **Library:** [`shamir-secret-sharing`](https://www.npmjs.com/package/shamir-secret-sharing)
- Each fragment alone reveals zero information about the secret (information-theoretic security)

### Why is this secure?

- **Passphrase is never stored.** It only exists in memory during encryption/decryption.
- **Each encryption produces unique output.** Random salt + random IV means encrypting the same seed twice gives completely different ciphertext.
- **GCM authentication** detects if a fragment has been tampered with or if the wrong passphrase is used — decryption fails rather than producing garbage.
- **Shamir splitting is information-theoretically secure.** A single fragment provides zero mathematical advantage to an attacker. You need the threshold number of fragments (2).
- **Two-layer protection.** Even after recombining fragments, you still need the passphrase to decrypt. Someone who obtains 2 fragments but doesn't know the passphrase cannot recover the seed.

## Seed phrase requirements

Aegis validates seed phrases against the [BIP39 standard](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki). A valid seed must:

- Contain **12, 15, 18, 21, or 24 words**
- Use only words from the **BIP39 English wordlist** (2048 words)
- Have a **valid checksum** (the last word encodes a checksum of the entropy)

### Examples

**Valid seeds:**

```
# 24 words — standard BIP39 test vector
abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art

# 12 words — generated by most wallets
journey cluster display fragile oak brief field security digital fetch skull emerge
```

**Invalid seeds (rejected by Aegis):**

```
# Wrong checksum — words are valid but the combination is mathematically invalid
tuna tiny arrow shadow keep moon meal negative direct stadium task ocean

# Invalid word — "cryptooo" is not in the BIP39 wordlist
bridge total merit solar adjust duty fiction average find clarify prize cryptooo

# Too few words — 11 words instead of 12
bridge total merit solar adjust duty fiction average find clarify prize

# Numbers — not BIP39 words
12345 total 12345 67890 duty 67890 lae45 67890 12345 67890 12345 67890
```

Aegis also normalizes input: extra spaces are trimmed and uppercase letters are converted to lowercase.

## Project structure

This is a **pnpm workspace monorepo** with two packages:

```
packages/
├── core/    aegis-core — crypto library (encryption, Shamir, validation, QR)
└── app/     aegis-app  — Electron + React desktop application
```

### `aegis-core`

Pure Node.js library that handles all cryptographic operations:

- `SeedValidator` — BIP39 validation and normalization
- `AESEncryption` — AES-256-GCM encrypt/decrypt with PBKDF2 key derivation
- `ShamirSecret` — 2-of-3 threshold secret sharing (split/combine)
- `generateQR` — QR code generation (PNG data URLs)
- `buildPDF` — PDF generation for fragment export

### `aegis-app`

Electron + React desktop app built with electron-vite. All crypto runs in the **main process** (Node.js) and is exposed to the renderer via IPC — the frontend never handles cryptographic operations directly.

## Getting started

### Prerequisites

- Node.js
- pnpm

### Install & run

```bash
# Install dependencies
pnpm install

# Run in development mode (launches Electron with HMR)
pnpm dev

# Build everything
pnpm build
```

### Run tests

```bash
# Run all tests
pnpm test

# Watch mode
pnpm test:watch
```

## How it was built

The project was developed in two phases:

1. **Core library first** — All the cryptographic logic was built and tested independently: BIP39 validation, AES-256-GCM encryption with PBKDF2 key derivation, and Shamir 2-of-3 secret sharing. Unit tests cover each module individually, and integration tests verify the full encrypt-then-decrypt round trip.

2. **Desktop app second** — The Electron + React application was co-developed with Claude (Anthropic's AI) using [Claude Code](https://claude.ai/code), running locally in the terminal. The app uses IPC to delegate all crypto to the Node.js main process while the React renderer handles the UI. electron-vite handles the build pipeline. This was my first experience building a project collaboratively with an AI assistant through prompt-driven development directly in the terminal.
